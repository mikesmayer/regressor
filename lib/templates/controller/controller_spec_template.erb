require 'rails_helper'

RSpec.describe <%= @controller.controller %>, type: :controller %> do

  # === Routes (REST) ===
  <%= @controller.rest_routes %>

  # === Callbacks (Before) ===
  <%= @controller.before_callbacks %>

  # === Callbacks (After) ===
  <%= @controller.after_callbacks %>

  # === Callbacks (Around) ===
  <%= @controller.around_callbacks %>

  # === Actions Specs ===

  # describe 'GET #index' do
    # context 'when user is logged in' do
    #   with :user
    #   before do
    #     sign_in user
    #     get :index
    #   end
    #   it { is_expected.to respond_with :ok }
    #   it { is_expected.to respond_with_content_type :html }
    #   it { is_expected.to render_with_layout :application }
    #   it { is_expected.to render_template :index }
    # end

    # context 'when user is logged out' do
    #   before do
    #     get :index
    #   end
    #   it { is_expected.to redirect_to new_session_path }
    #   it { is_expected.to set_the_flash(:warning).to('Please log in.') }
    #   it { is_expected.to set_session(:return_to).to(posts_path) }
    # end
 # end

  # describe "GET #index" do
    # it "populates an array of contacts" do
    #   contact = Factory(:contact)
    #   get :index
    #   assigns(:contacts).should eq([contact])
    # end

    # it "renders the :index view" do
    #   get :index
    #   response.should render_template :index
    # end
  # end

  # describe "GET #show" do
    # it "assigns the requested contact to @contact" do
    #   contact = Factory(:contact)
    #   get :show, id: contact
    #   assigns(:contact).should eq(contact)
    # end

    # it "renders the #show view" do
    #   get :show, id: Factory(:contact)
    #   response.should render_template :show
    # end
  # end

  # describe "GET #new" do
  #   it "assigns a home, office, and mobile phone to the new contact" do
  #     get :new
  #     assigns(:contact).phones.map{ |p| p.phone_type }.should eq %w(home office mobile)
  #   end
  # end

  # describe "POST create" do
    # context "with valid attributes" do
    #   it "creates a new contact" do
    #     expect{ post :create, contact: Factory.attributes_for(:contact)
    #           }.to change(Contact,:count).by(1)
    #   end
    #
    #   it "redirects to the new contact" do
    #     post :create, contact: Factory.attributes_for(:contact)
    #     response.should redirect_to Contact.last
    #   end
    # end

    # context "with invalid attributes" do
    #   it "does not save the new contact" do
    #     expect{ post :create, contact: Factory.attributes_for(:invalid_contact)
    #           }.to_not change(Contact,:count)
    #   end
    #
    #   it "re-renders the new method" do
    #     post :create, contact: Factory.attributes_for(:invalid_contact)
    #     response.should render_template :new
    #   end
    # end
  # end

  # describe 'PUT update' do
    # before :each do
    #   @contact = Factory(:contact, firstname: "Lawrence", lastname: "Smith")
    # end

    # context "valid attributes" do
    #   it "located the requested @contact" do
    #     put :update, id: @contact, contact: Factory.attributes_for(:contact)
    #     assigns(:contact).should eq(@contact)
    #   end
    #
    #   it "changes @contact's attributes" do
    #     put :update, id: @contact,
    #         contact: Factory.attributes_for(:contact, firstname: "Larry", lastname: "Smith")
    #     @contact.reload
    #     @contact.firstname.should eq("Larry")
    #     @contact.lastname.should eq("Smith")
    #   end
    #
    #   it "redirects to the updated contact" do
    #     put :update, id: @contact, contact: Factory.attributes_for(:contact)
    #     response.should redirect_to @contact
    #   end
    # end

    # context "invalid attributes" do
    #   it "locates the requested @contact" do
    #     put :update, id: @contact, contact: Factory.attributes_for(:invalid_contact)
    #     assigns(:contact).should eq(@contact)
    #   end
    #
    #   it "does not change @contact's attributes" do
    #     put :update, id: @contact,
    #         contact: Factory.attributes_for(:contact, firstname: "Larry", lastname: nil)
    #     @contact.reload
    #     @contact.firstname.should_not eq("Larry")
    #     @contact.lastname.should eq("Smith")
    #   end
    #
    #   it "re-renders the edit method" do
    #     put :update, id: @contact, contact: Factory.attributes_for(:invalid_contact)
    #     response.should render_template :edit
    #   end
    # end
  # end

  # describe 'DELETE destroy' do
    # before :each do
    #   @contact = Factory(:contact)
    # end

    # it "deletes the contact" do
    #   expect{
    #     delete :destroy, id: @contact
    #   }.to change(Contact,:count).by(-1)
    # end

    # it "redirects to contacts#index" do
    #   delete :destroy, id: @contact
    #   response.should redirect_to contacts_url
    # end
  # end

 # context "GET new" do

    # it "assigns a blank subscription to the view" do
    #   get :new
    #   expect(assigns(:subscription)).to be_a_new(Subscription)
    # end

  # end

  # context "POST create" do

    # it "redirects to pending subscriptions page" do
    #   params = { subscription: { email: "e@example.tld", start_on: "2014-12-31" } }
    #   post :create, params
    #
    #   expect(response).to redirect_to(pending_subscriptions_path)
    # end

    # it "calls Subscription.create_and_request_confirmation(params)" do
    #   email = "e@example.tld"
    #   start_on = "2015-02-28"
    #
    #   expect(Subscription).to receive(:create_and_request_confirmation)
    #                               .with({ email: email, start_on: start_on })
    #
    #   post :create, { subscription: { email: email, start_on: start_on } }
    # end

    # it "raises an error if missing params email" do
    #   params = { subscription: { start_on: "2015-09-28" } }
    #
    #   expect do
    #     post :create, params
    #   end.to raise_error ActiveRecord::RecordInvalid
    # end

  # end

  # context "GET confirm" do

    # it "confirms the subscription" do
    #   subscription = create(:subscription,
    #                         email: "e@e.tld",
    #                         confirmation_token: Subscription.generate_confirmation_token
    #   )
    #   expect(subscription.confirmed?).to eq(false)
    #
    #   params = { confirmation_token: subscription.confirmation_token }
    #   get :confirm, params
    #
    #   expect(subscription.reload.confirmed?).to eq(true)
    #   expect(assigns(:subscription)).to eq(subscription)
    # end

    # it "responds with 404 Not Found for unknown confirmation token" do
    #   params = { confirmation_token: "an-unknown-token" }
    #   expect do
    #     get :confirm, params
    #   end.to raise_error ActiveRecord::RecordNotFound
    # end

  # end

  # context 'when not logged in' do
	 #  describe '.authenticate -- EXAMPLE: use . when referring to a class method name' do
	 #  end
	 #  describe '#admin? -- EXAMPLE: use . when referring to an instance method name' do
	 #  end
  # end

  # context 'when logged in' do
    #let(:user) do
    #  @request.env['devise.mapping'] = Devise.mappings[:user]
    # user = FactoryGirl.create(:user)
    # user.confirm # or set a confirmed_at inside the factory. Only necessary if you are using the "confirmable" module
    # sign_in user
    #end

    #login_user

    #let(:orgacct) do
    #  FactoryGirl.create(:orgacct)
    #end

    #let(:personacct) do
    #  FactoryGirl.create(:personacct, orgacct: orgacct, user: user)
    #end

    #let(:valid_attributes) do
    #  { client_company: { orgname: 'Test' } }
    #end

    #let(:invalid_attributes) do
    #  { client_company: { orgname: nil } }
    #end

    #it { should use_before_action(:authenticate_user!) }

  # end

  context "GET index" do

    ## NORMALLY, you DO NOT want render_views, or you only want to call it in
    ## a single context.
    ## More on render_views:
    ## https://www.relishapp.com/rspec/rspec-rails/v/3-1/docs/controller-specs/render-views
    # render_views # ONLY have this if you're certain you need it

    it "reads like a sentence (almost)" do

      # get :index

      # params = { id: 123 }
      # get :edit, params

      # params = { widget: { description: 'Hello World' } }
      # params.merge!(format: :js) # Specify format for AJAX/JS responses (e.g. create.js.erb view)
      # post :create, params

      # Testing 404s in controllers (assuming default Rails handling of RecordNotFound)
      # expect { delete :destroy, { id: 'unknown' } }.to raise_error(ActiveRecord::RecordNotFound)

      ## Rails `:symbolized` status codes at end of each status code page at http://httpstatus.es/
      # expect(response).to have_http_status(:success) # 200
      # expect(response).to have_http_status(:forbidden) # 403

      # expect(response).to redirect_to foo_path
      # expect(response).to render_template(:template_filename_without_extension)
      # expect(response).to render_template(:destroy)

      ## Need response.body? Requires render_views call outside "it" block (see above & read given URL)
      # expect(response.body).to match /Bestsellers/
      # expect(response.body).to include "Bestsellers"

      # expect(response.headers["Content-Type"]).to eq "text/html; charset=utf-8"
      # expect(response.headers["Content-Type"]).to eq "text/javascript; charset=utf-8"

      ## assigns(:foobar) accesses the @foobar instance variable
      ## the controller method made available to the view

      ## Think of assigns(:widgets) as @widgets in the controller method
      # expect(assigns(:widgets)).to eq([widget1, widget2, widget3])

      ## Think of assigns(:product) as @product in the controller method
      # expect(assigns(:product)).to eq(bestseller)
      # expect(assigns(:cat)).to be_cool # cat.cool is a boolean, google "rspec predicate matchers"
      # expect(assigns(:employee)).to be_a_new(Employee)


      ## Asserting flash messages
      # expect(flash[:notice]).to eq "Congratulations on buying our stuff!"
      # expect(flash[:error]).to eq "Buying our stuff failed :-("
      # expect(flash[:alert]).to eq "You didn't buy any of our stuff!!!"

      ## Oi Eliot - TODO: add cookies and session examples here

      ## Query the db to assert changes persisted
      # expect(Invoice.count).to eq(1)

      ## Reload from db an object fetched in test setup when its record in db
      ## is updated by controller method, otherwise you're testing stale data
      # employee.reload
      # invoice.reload
      # product.reload
      # widget.reload

    end

  #context "POST create" do
  #context "GET show" do
  #context "PATCH update" do (or PUT update)
  #context "DELETE destroy" do
  #context "GET new" do
  #context "GET edit" do


  end

  # describe "#create" do
  #   subject { post :create, :group_id => group_id, :user => attributes }
  #
  #   let(:group_id) { mock(‘group_id’) }
  #   let(:group)    { mock(‘group’) }
  #   let(:user)     { mock(‘user’) }
  #
  #   before do
  #     Group.should_receive(:find).with(group_id).and_return(group)
  #     group.should_receive(:create_user).with(attributes).and_return(users)
  #   end
  #
  #   context ‘when attributes are valid’ do
  #     it ‘saves the user and redirects to the index page’ do
  #       user.should_receive(:persisted?).and_return(true)
  #       subject.should redirect_to(:users)
  #     end
  #   end
  #
  #   context ‘when attributes are not valid’ do
  #     it ‘saves the user and redirects to the index page’ do
  #       user.should_receive(:persisted?).and_return(false)
  #       subject.should render_template(:new)
  #     end
  #   end
  # end

  # subject { post :create, :group_id => group_id, :user => attributes }
  #
  #   let(:group_id) { mock(‘group_id’) }
  #   let(:group)    { mock(‘group’) }
  #
  #   describe ‘#create’ do
  #   context ‘when group is not found’ do
  #
  #   before do
  #     Group.should_receive(:find).with(group_id).
  #       and_raise(ActiveRecord::RecordNotFound)
  #   end
  #
  #     it { should render_template(:not_found) }
  #   end
  # end

  # describe FindReaction do
  #   before :all do
  #     @post = build :post, locale: "en", type: "basic"
  #   end
  #   before :each do
  #     @post.reaction = nil
  #   end
  #
  #   describe :reaction do
  #     subject { FindReaction.for(@post).reaction }
  #     #Spec 1
  #     context "there are no reaction templates" do
  #       it {should be_blank }
  #     end
  #     #Spec 2
  #     context "reaction templates exist, but non fitting" do
  #       before :each do
  #         reaction1 = ReactionTemplate.create! locale: "de", subtypes: ["basic", "top_x"]
  #         reaction2 = ReactionTemplate.create! locale: "en", subtypes: ["slideshow", "top_x"]
  #       end
  #       it {should be_blank }
  #     end
  #     #Spec 3
  #     context "fitting reaction templates exist" do
  #       before :each do
  #         @reaction1 = ReactionTemplate.create! locale: @post.locale, subtypes: [@post.type, "top_x"]
  #         @reaction2 = ReactionTemplate.create! locale: @post.locale, subtypes: [@post.type, "top_x"]
  #         @reaction3 = ReactionTemplate.create! locale: @post.locale, subtypes: ["slideshow", "top_x"]
  #       end
  #       it {should_not be_blank}
  #       it {should eq @reaction2}
  #     end
  #   end
  #
  #   describe :attach do
  #     #Spec 4
  #     context "attaching a reaction to post" do
  #       before :each do
  #         @reaction = ReactionTemplate.create! locale: @post.locale, subtypes: [@post.type, "top_x"]
  #       end
  #       it "should change posts reaction template" do
  #         expect {
  #           FindReaction.for(@post).attach
  #         }.to change{@post.reaction_template}.from(nil).to(@reaction)
  #       end
  #     end
  #   end
  # end

end